# This workflow:
#  - builds and uploads a binary artifact for each Windows architecture
#  - tests the runner on Windows with a Forgejo server container running on Windows Subsystem for Linux (WSL)
#  - releases the binary artifacts as a GitHub release

name: Build Release
run-name: Build Release ${{ inputs.tag }}

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release'
        type: string
        required: true
      goal:
        description: 'Goal of run'
        type: choice
        required: false
        options:
          - release
          - draft
          - test-fork
        default: release

env:
  MAX_WAIT_ITERATIONS: 30

jobs:

  test-docker:
    name: Test docker running on Windows
    runs-on: windows-latest

    steps:

      - name: Windows - Setup Windows Subsystem for Linux (WSL)
        uses: Vampire/setup-wsl@v6
        with:
          distribution: Alpine
          wsl-shell-user: root
          additional-packages: bash

      - name: Windows - Get WSL IP
        id: get-ip
        run: |
          $WSL_IP_RAW = (wsl -d Alpine ip -4 addr show eth0 | Select-String -Pattern 'inet\s+(\d+\.\d+\.\d+\.\d+)')
          if ($WSL_IP_RAW) {
            foreach ($match in $WSL_IP_RAW.Matches) {
              if ($match.Groups[1].Value) {
                $WSL_IP = $match.Groups[1].Value
                break
              }
            }
          }
          if (-not $WSL_IP) {
            $WSL_IP = (wsl -d Alpine hostname -I).Trim().Split(" ")[0]
          }
          if (-not $WSL_IP) {
            Write-Error "Could not determine WSL IP address"
            exit 1
          }
          $WSL_IP = $WSL_IP.ToString().Trim()
          Write-Output "Detected WSL_IP: '$WSL_IP'"
          # Additional validation: Ping the IP from Windows to ensure reachability
          if (Test-Connection -ComputerName $WSL_IP -Count 1 -Quiet) {
            Write-Output "WSL IP is reachable via ping."
          } else {
            Write-Error "WSL IP '$WSL_IP' is not reachable from Windows. Check WSL networking."
            exit 1
          }
          if ($WSL_IP -notmatch '^\d+\.\d+\.\d+\.\d+$') {
            Write-Error "Invalid WSL IP address detected: '$WSL_IP'"
            exit 1
          }
          "WSL_IP=$WSL_IP" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: WSL - Install Docker
        shell: wsl-bash {0}
        run: |
          apk --update add --no-cache docker curl socat net-tools

          rc-update add docker default
          openrc default

          # Wait for Docker to be ready
          i=0
          until docker info > /dev/null 2>&1 || (( i == ${{ env.MAX_WAIT_ITERATIONS }} )); do
            echo "Waiting for Docker to be ready... ($(( ++i ))/${{ env.MAX_WAIT_ITERATIONS }})"
            sleep 1
          done
          [ $i -lt ${{ env.MAX_WAIT_ITERATIONS }} ] && echo "Docker is ready!" || { echo "Timed out waiting for Docker" ; exit 1; }

      - name: WSL - Expose Docker Socket
        shell: wsl-bash {0}
        run: |
          # Pre-check: Ensure Docker socket exists
          if [ ! -S /var/run/docker.sock ]; then
            echo "Error: Docker socket /var/run/docker.sock not found or not a socket."
            ls -l /var/run/  # Debug: Show directory contents
            docker info      # Debug: Confirm Docker status
            exit 1
          fi
          # Start socat with logging, force IPv4, and retry if needed
          i=0
          until [ $i -ge 3 ]; do  # Retry up to 3 times
            echo "Attempting to start socat (try $((i+1))/3)..."
            nohup socat TCP4-LISTEN:2375,bind=0.0.0.0,fork,reuseaddr UNIX-CONNECT:/var/run/docker.sock > /tmp/socat.log 2>&1 &
            sleep 2
            if pgrep socat; then
              echo "Socat started successfully."
              break
            else
              echo "Socat failed to start on try $((i+1)). Killing any remnants..."
              pkill socat || true
            fi
            i=$((i+1))
          done
          if [ $i -ge 3 ]; then
            echo "Failed to start socat after retries. Dumping logs:"
            cat /tmp/socat.log || echo "No log file created."
            ps aux | grep socat  # Debug: Show processes
            exit 1
          fi

      - name: WSL - Verify Docker TCP Port Inside WSL
        shell: wsl-bash {0}
        run: |
          # Check if port 2375 is listening
          i=0
          until netstat -tuln | grep ':2375' || (( i == ${{ env.MAX_WAIT_ITERATIONS }} )); do
            echo "Waiting for port 2375 inside WSL... ($(( ++i ))/${{ env.MAX_WAIT_ITERATIONS }})"
            sleep 1
          done
          if [ $i -lt ${{ env.MAX_WAIT_ITERATIONS }} ]; then
            echo "Port 2375 is listening inside WSL!"
            # Test connection inside WSL
            if curl -s --fail http://localhost:2375/version; then
              echo "Docker API responds inside WSL."
            else
              echo "Docker API test failed inside WSL."
              netstat -tuln | grep 2375  # Extra debug
              exit 1
            fi
          else
            echo "Timed out: Port 2375 not listening inside WSL. Socat logs:"
            cat /tmp/socat.log || echo "No log file."
            echo "Debug: Full netstat output"
            netstat -tuln
            echo "Debug: Processes involving socat or docker"
            ps aux | grep -E 'socat|docker'
            echo "Debug: Docker socket details"
            ls -l /var/run/docker.sock
            exit 1
          fi

      - name: Windows - Allow Docker Port in Firewall
        run: |
          netsh advfirewall firewall add rule name="Allow WSL Docker TCP 2375" dir=in action=allow protocol=TCP localport=2375


      - name: Windows - Wait for Docker TCP Exposure
        run: |
          $DOCKER_HOST = "tcp://${{ env.WSL_IP }}:2375"
          Write-Output "Waiting for Docker at $DOCKER_HOST to be accessible..."
          $maxAttempts = ${{ env.MAX_WAIT_ITERATIONS }}
          $attempt = 0
          do {
            $attempt++
            try {
              # Force IPv4 by parsing the IP
              $ip = [System.Net.IPAddress]::Parse('${{ env.WSL_IP }}')
              $client = New-Object System.Net.Sockets.TcpClient($ip, 2375)
              $client.Close()
              Write-Output "Docker TCP port is open! (Attempt $attempt)"
              break
            } catch {
              Write-Output "Attempt $attempt/$maxAttempts failed: $_"
              Start-Sleep -Seconds 1
            }
          } while ($attempt -lt $maxAttempts)
          if ($attempt -ge $maxAttempts) {
            Write-Error "Timed out waiting for Docker TCP exposure"
            exit 1
          }
          # Quick test: Query Docker version from Windows
          $env:DOCKER_HOST = $DOCKER_HOST
          docker version
        env:
          DOCKER_HOST: tcp://${{ env.WSL_IP }}:2375
